<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced 24-Hour Daily Task Planner</title>
<link href="/dist/output.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1f2937;
    }
    ::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #6b7280;
    }
    @media print {
      body {
        background-color: white !important;
        color: black !important;
      }
      .no-print {
        display: none !important;
      }
      .print-table, .print-table th, .print-table td {
        border: 1px solid #ddd !important;
        color: black !important;
        background-color: white !important;
      }
      .print-table th, .print-table td {
        padding: 8px;
      }
      .print-table input, .print-table select, .print-table textarea {
        border: none !important;
        background: transparent !important;
        box-shadow: none !important;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        resize: none !important;
      }
      .print-table select {
        padding-right: 0;
      }
      .add-task-btn, .delete-task {
        display: none !important;
      }
      .summary-section {
        border: 1px solid #ddd !important;
        background-color: white !important;
        color: black !important;
      }
    }

    /* Dropdown fix for dark mode */
    select option {
      background-color: #111827;
      color: white;
    }
    
    .task-row {
      transition: all 0.3s ease;
    }
    
    .add-task-btn {
      opacity: 0.6;
      transition: opacity 0.3s ease;
    }
    
    .add-task-btn:hover {
      opacity: 1;
    }
    
    .duration-cell {
      font-weight: 600;
    }
    
    .summary-section {
      background-color: #1f2937;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-top: 1.5rem;
    }
    
    .category-time-bar {
      height: 24px;
      border-radius: 12px;
      margin: 8px 0;
      transition: width 0.5s ease;
    }
    
    .progress-label {
      position: absolute;
      right: 10px;
      color: white;
      font-weight: 600;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
    }
    
    .manual-adjust {
      border: 1px solid #f59e0b !important;
    }
    
    /* Responsive adjustments */
    @media (max-width: 640px) {
      .container {
        padding: 0.5rem;
      }
      
      .task-table th, .task-table td {
        padding: 0.5rem;
      }
      
      .task-table th:nth-child(4),
      .task-table th:nth-child(5),
      .task-table td:nth-child(4),
      .task-table td:nth-child(5) {
        max-width: 120px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      .controls-container {
        flex-direction: column;
        gap: 0.5rem;
      }
      
      .date-control {
        width: 100%;
        justify-content: space-between;
      }
      
      .button-group {
        width: 100%;
        justify-content: space-between;
      }
      
      .button-group button {
        flex: 1;
        margin: 0 0.25rem;
      }
    }
    
    @media (max-width: 768px) {
      .task-table {
        font-size: 0.875rem;
      }
      
      .task-table th, .task-table td {
        padding: 0.5rem;
      }
    }

    .time-error {
      border: 1px solid #ef4444 !important;
    }
    
    .error-message {
      color: #ef4444;
      font-size: 0.75rem;
      margin-top: 0.25rem;
      display: none;
    }
    
    /* Connection status indicator */
    .connection-status {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      z-index: 1000;
    }
    
    .online {
      background-color: #10b981;
      color: white;
    }
    
    .offline {
      background-color: #ef4444;
      color: white;
    }
    
    /* Auth modal styles */
    .auth-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .auth-content {
      background-color: #1f2937;
      border-radius: 0.5rem;
      padding: 2rem;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
    }
    
    .auth-tabs {
      display: flex;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid #374151;
    }
    
    .auth-tab {
      padding: 0.5rem 1rem;
      cursor: pointer;
      color: #9ca3af;
      border-bottom: 2px solid transparent;
    }
    
    .auth-tab.active {
      color: #60a5fa;
      border-bottom: 2px solid #60a5fa;
    }
    
    .auth-form {
      display: none;
    }
    
    .auth-form.active {
      display: block;
    }
    
    .loading {
      opacity: 0.7;
      pointer-events: none;
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-200">

  <!-- Auth Modal -->
  <div id="auth-modal" class="auth-modal">
    <div class="auth-content">
      <div class="auth-tabs">
        <div class="auth-tab active" data-tab="login">Login</div>
        <div class="auth-tab" data-tab="register">Register</div>
        <div class="auth-tab" data-tab="forgot">Forgot Password</div>
      </div>
      
      <!-- Login Form -->
      <form id="login-form" class="auth-form active">
        <div class="mb-4">
          <label for="login-email" class="block text-sm font-medium mb-1">Email</label>
          <input type="email" id="login-email" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <div class="mb-6">
          <label for="login-password" class="block text-sm font-medium mb-1">Password</label>
          <input type="password" id="login-password" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Login</button>
        <div id="login-error" class="text-red-400 text-sm mt-2 hidden"></div>
      </form>
      
      <!-- Register Form -->
      <form id="register-form" class="auth-form">
        <div class="mb-4">
          <label for="register-name" class="block text-sm font-medium mb-1">Full Name</label>
          <input type="text" id="register-name" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <div class="mb-4">
          <label for="register-email" class="block text-sm font-medium mb-1">Email</label>
          <input type="email" id="register-email" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <div class="mb-4">
          <label for="register-password" class="block text-sm font-medium mb-1">Password</label>
          <input type="password" id="register-password" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <div class="mb-6">
          <label for="register-confirm" class="block text-sm font-medium mb-1">Confirm Password</label>
          <input type="password" id="register-confirm" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <button type="submit" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Register</button>
        <div id="register-error" class="text-red-400 text-sm mt-2 hidden"></div>
      </form>
      
      <!-- Forgot Password Form -->
      <form id="forgot-form" class="auth-form">
        <div class="mb-6">
          <label for="forgot-email" class="block text-sm font-medium mb-1">Email</label>
          <input type="email" id="forgot-email" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <button type="submit" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Reset Password</button>
        <div id="forgot-message" class="text-green-400 text-sm mt-2 hidden"></div>
      </form>
      
      <!-- OTP Verification Form -->
      <form id="otp-form" class="auth-form">
        <div class="mb-4">
          <label for="otp-email" class="block text-sm font-medium mb-1">Email</label>
          <input type="email" id="otp-email" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required readonly>
        </div>
        <div class="mb-4">
          <label for="otp-code" class="block text-sm font-medium mb-1">OTP Code</label>
          <input type="text" id="otp-code" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <div class="mb-4">
          <label for="new-password" class="block text-sm font-medium mb-1">New Password</label>
          <input type="password" id="new-password" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <div class="mb-6">
          <label for="confirm-password" class="block text-sm font-medium mb-1">Confirm Password</label>
          <input type="password" id="confirm-password" class="w-full bg-gray-800 border border-gray-700 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
        </div>
        <button type="submit" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Reset Password</button>
        <div id="otp-message" class="text-green-400 text-sm mt-2 hidden"></div>
        <div id="otp-error" class="text-red-400 text-sm mt-2 hidden"></div>
      </form>
    </div>
  </div>

  <!-- Main Application (hidden until authenticated) -->
  <div id="app-container" class="hidden">
    <div class="container mx-auto p-2 sm:p-4 md:p-6 lg:p-8">
      <!-- Header Section with User Info -->
      <header class="text-center mb-4 sm:mb-6 md:mb-8">
        <div class="flex justify-between items-center mb-2">
          <div></div> <!-- Spacer -->
          <h1 class="text-xl sm:text-2xl md:text-3xl lg:text-4xl font-bold text-cyan-400 tracking-wide">Enhanced Daily Task Planner</h1>
          <div class="flex items-center">
            <span id="user-name" class="text-sm text-gray-400 mr-2"></span>
            <button id="logout-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 rounded text-xs">Logout</button>
          </div>
        </div>
        <p class="text-xs sm:text-sm text-gray-400">Plan and track your day with automatic time adjustment</p>
      </header>

      <!-- Controls Section -->
      <div class="no-print flex flex-col sm:flex-row justify-between items-center mb-4 sm:mb-6 bg-gray-800 p-3 sm:p-4 rounded-lg shadow-lg controls-container">
        <div class="flex items-center space-x-2 sm:space-x-4 mb-2 sm:mb-0 date-control">
          <label for="date-picker" class="font-semibold text-gray-300 text-sm sm:text-base">Select Date:</label>
          <input type="date" id="date-picker" class="bg-gray-700 border border-gray-600 text-white rounded-md px-2 sm:px-3 py-1 sm:py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500 text-sm sm:text-base">
        </div>
        <div class="flex items-center space-x-1 sm:space-x-2 button-group">
          <button id="clear-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 sm:py-2 px-2 sm:px-4 rounded-md transition duration-300 text-xs sm:text-base">
            Clear Day
          </button>
          <button id="print-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 sm:py-2 px-2 sm:px-4 rounded-md transition duration-300 text-xs sm:text-base">
            Print Schedule
          </button>
          <button id="save-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-1 sm:py-2 px-2 sm:px-4 rounded-md transition duration-300 text-xs sm:text-base">
            Save to Cloud
          </button>
          <button id="load-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 sm:py-2 px-2 sm:px-4 rounded-md transition duration-300 text-xs sm:text-base">
            Load from Cloud
          </button>
        </div>
      </div>

      <!-- Task Table Section -->
      <div class="overflow-x-auto bg-gray-800 rounded-lg shadow-lg">
        <table id="task-table" class="w-full text-xs sm:text-sm text-left text-gray-300 print-table task-table">
          <thead class="text-xs text-gray-400 uppercase bg-gray-700">
            <tr>
              <th class="px-2 sm:px-4 py-2">Start</th>
              <th class="px-2 sm:px-4 py-2">End</th>
              <th class="px-2 sm:px-4 py-2">Duration</th>
              <th class="px-2 sm:px-4 py-2">Planned Task</th>
              <th class="px-2 sm:px-4 py-2">Actual Activity</th>
              <th class="px-2 sm:px-4 py-2">Category</th>
              <th class="px-2 sm:px-4 py-2 no-print">Actions</th>
            </tr>
          </thead>
          <tbody id="table-body"></tbody>
        </table>
      </div>

      <!-- Summary Section -->
      <div class="summary-section mt-4 sm:mt-6">
        <h2 class="text-lg sm:text-xl font-bold text-cyan-400 mb-2 sm:mb-4">Daily Summary</h2>
        <div id="category-summary" class="grid grid-cols-1 md:grid-cols-2 gap-3 sm:gap-4">
          <!-- Summary will be dynamically generated here -->
        </div>
        <div class="mt-3 sm:mt-4 pt-3 sm:pt-4 border-t border-gray-700">
          <p class="text-base sm:text-lg font-semibold">Total Tracked Time: <span id="total-time">0h 0m</span></p>
          <p class="text-sm text-gray-400 mt-1">Note: Total time is capped at 24 hours</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Connection Status Indicator -->
  <div id="connection-status" class="connection-status offline">Offline</div>

  <script>
    // Global variables
    let currentUser = null;
    let authToken = null;
    let manualAdjustments = new Set();
    
    // Custom HEX category colors
    const categories = {
      'Default': '#4b5563',
      'Work': '#283618',
      'Personal': '#003049',
      'Sleep': '#fb6f92',
      'Exercise': '#2a9d8f',
      'Meal': '#450920',
      'Learning': '#22333b',
      'Break': '#985277',
    };

    // API configuration
    const API_BASE_URL = '/api';

    // DOM elements
    let datePicker, tableBody, clearBtn, printBtn, saveBtn, loadBtn;
    let categorySummary, totalTimeElement, connectionStatus;

    // Task Planner Functions
    const generateTimeOptions = () => {
      const options = [];
      for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 5) {
          const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
          options.push(timeString);
        }
      }
      return options;
    };

    const generateEndTimeOptions = (startTime) => {
      const options = [];
      const [startHour, startMinute] = startTime.split(':').map(Number);
      const startMinutes = startHour * 60 + startMinute;
      
      // Generate times only from start time until midnight (23:59)
      for (let minutes = startMinutes + 5; minutes <= 23 * 60 + 59; minutes += 5) {
        const hour = Math.floor(minutes / 60);
        const minute = minutes % 60;
        const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        options.push(timeString);
      }
      return options;
    };

    const calculateDuration = (startTime, endTime) => {
      const [startHours, startMinutes] = startTime.split(':').map(Number);
      const [endHours, endMinutes] = endTime.split(':').map(Number);
      
      let totalMinutes = (endHours * 60 + endMinutes) - (startHours * 60 + startMinutes);
      
      // Handle overnight tasks (end time is next day)
      if (totalMinutes < 0) {
        totalMinutes += 24 * 60;
      }
      
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      
      return { hours, minutes, totalMinutes };
    };

    const formatDuration = (hours, minutes) => {
      if (hours === 0 && minutes === 0) return '0m';
      if (hours === 0) return `${minutes}m`;
      if (minutes === 0) return `${hours}h`;
      return `${hours}h ${minutes}m`;
    };

    const timeToMinutes = (timeStr) => {
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    };

    const minutesToTime = (totalMinutes) => {
      // Handle overnight (more than 24 hours)
      totalMinutes = totalMinutes % (24 * 60);
      if (totalMinutes < 0) totalMinutes += 24 * 60;
      
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    };

    const createTaskRow = (startTime = '00:00', endTime = '00:30', taskData = null) => {
      const row = document.createElement('tr');
      row.className = 'task-row border-b border-gray-700';
      
      // Generate unique ID for this row
      const rowId = Date.now() + Math.floor(Math.random() * 1000);
      row.dataset.rowId = rowId;

      // Calculate initial duration
      const duration = calculateDuration(startTime, endTime);

      // Start Time cell
      const startCell = document.createElement('td');
      startCell.className = 'px-2 sm:px-4 py-2';
      const startSelect = document.createElement('select');
      startSelect.className = 'start-time bg-gray-900 border-0 border-b border-gray-400 text-white focus:ring-0 focus:border-cyan-400 p-1 text-xs sm:text-sm';
      generateTimeOptions().forEach(time => {
        const option = document.createElement('option');
        option.value = time;
        option.textContent = time;
        option.selected = time === startTime;
        startSelect.appendChild(option);
      });
      startCell.appendChild(startSelect);

      // End Time cell
      const endCell = document.createElement('td');
      endCell.className = 'px-2 sm:px-4 py-2';
      const endSelect = document.createElement('select');
      endSelect.className = 'end-time bg-gray-900 border-0 border-b border-gray-400 text-white focus:ring-0 focus:border-cyan-400 p-1 text-xs sm:text-sm';

      // Generate end time options based on start time
      const endTimeOptions = generateEndTimeOptions(startTime);
      endSelect.innerHTML = '';
      endTimeOptions.forEach(time => {
        const option = document.createElement('option');
        option.value = time;
        option.textContent = time;
        option.selected = time === endTime;
        endSelect.appendChild(option);
      });
      endCell.appendChild(endSelect);

      // Duration cell
      const durationCell = document.createElement('td');
      durationCell.className = 'px-2 sm:px-4 py-2 duration-cell';
      durationCell.textContent = formatDuration(duration.hours, duration.minutes);
      durationCell.dataset.totalMinutes = duration.totalMinutes;

      // Planned Task
      const planCell = document.createElement('td');
      planCell.className = 'px-2 sm:px-4 py-2';
      const planInput = document.createElement('input');
      planInput.type = 'text';
      planInput.placeholder = 'Plan...';
      planInput.className = 'planned-task w-full bg-transparent border-0 border-b border-gray-400 text-white focus:ring-0 focus:border-cyan-400 p-1 text-xs sm:text-sm';
      if (taskData) planInput.value = taskData.plan || '';
      planCell.appendChild(planInput);

      // Actual Activity
      const actualCell = document.createElement('td');
      actualCell.className = 'px-2 sm:px-4 py-2';
      const actualInput = document.createElement('textarea');
      actualInput.placeholder = 'Actual...';
      actualInput.rows = 1;
      actualInput.className = 'actual-activity w-full bg-transparent border-0 border-b border-gray-400 text-white focus:ring-0 focus:border-cyan-400 p-1 resize-none text-xs sm:text-sm';
      if (taskData) actualInput.value = taskData.actual || '';
      actualInput.addEventListener('input', () => {
        actualInput.style.height = 'auto';
        actualInput.style.height = `${actualInput.scrollHeight}px`;
      });
      actualCell.appendChild(actualInput);

      // Category
      const categoryCell = document.createElement('td');
      categoryCell.className = 'px-2 sm:px-4 py-2';
      const categorySelect = document.createElement('select');
      categorySelect.className = 'category-select bg-gray-900 border-0 border-b border-gray-400 text-white focus:ring-0 focus:border-cyan-400 p-1 text-xs sm:text-sm';
      Object.keys(categories).forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = cat;
        if (taskData) option.selected = (cat === taskData.category);
        else option.selected = (cat === 'Default');
        categorySelect.appendChild(option);
      });
      categoryCell.appendChild(categorySelect);

      // Actions cell with delete button
      const actionsCell = document.createElement('td');
      actionsCell.className = 'px-2 sm:px-4 py-2 no-print';
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-task bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-2 rounded text-xs';
      deleteBtn.textContent = 'Delete';
      actionsCell.appendChild(deleteBtn);

      // Add row to table
      row.appendChild(startCell);
      row.appendChild(endCell);
      row.appendChild(durationCell);
      row.appendChild(planCell);
      row.appendChild(actualCell);
      row.appendChild(categoryCell);
      row.appendChild(actionsCell);
      
      // Set row color based on category
      updateRowColor(row, taskData ? taskData.category : 'Default');
      
      return row;
    };

    const updateDuration = (row) => {
      const startSelect = row.querySelector('.start-time');
      const endSelect = row.querySelector('.end-time');
      const durationCell = row.querySelector('.duration-cell');
      
      const duration = calculateDuration(startSelect.value, endSelect.value);
      durationCell.textContent = formatDuration(duration.hours, duration.minutes);
      durationCell.dataset.totalMinutes = duration.totalMinutes;
    };

    const addNewTaskRow = (afterRow, startTime, endTime) => {
      const newRow = createTaskRow(startTime, endTime);
      tableBody.insertBefore(newRow, afterRow.nextSibling);
      
      // Add "+" button to the new row
      addPlusButton(newRow);
      
      // Remove "+" button from the previous row
      const existingPlusBtn = afterRow.querySelector('.add-task-btn');
      if (existingPlusBtn) {
        existingPlusBtn.remove();
      }
      
      saveData().catch(error => {
            console.error('Error saving data:', error);
          });
      updateSummary();
      return newRow;
    };

    const addPlusButton = (row) => {
      const lastCell = row.lastElementChild;
      // Remove any existing plus button first
      const existingBtn = lastCell.querySelector('.add-task-btn');
      if (existingBtn) {
        existingBtn.remove();
      }
      
      const addBtn = document.createElement('button');
      addBtn.className = 'add-task-btn ml-2 bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-2 rounded text-xs';
      addBtn.textContent = '+';
      addBtn.title = 'Add new task after this one';
      
      addBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const startTime = row.querySelector('.end-time').value;
        const [hours, minutes] = startTime.split(':').map(Number);
        const endMinutes = (minutes + 30) % 60;
        const endHours = minutes + 30 >= 60 ? (hours + 1) % 24 : hours;
        const endTime = `${endHours.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;
        
        addNewTaskRow(row, startTime, endTime);
      });
      
      lastCell.appendChild(addBtn);
    };

    const updateRowColor = (row, category) => {
      const color = categories[category] || categories['Default'];
      // Apply color with opacity for better text readability
      row.style.backgroundColor = color + 'cc';
    };

    const validateTimeContinuity = () => {
      const rows = tableBody.querySelectorAll('tr');
      let totalMinutes = 0;
      let isValid = true;
      
      rows.forEach(row => {
        const durationCell = row.querySelector('.duration-cell');
        const minutes = parseInt(durationCell.dataset.totalMinutes) || 0;
        totalMinutes += minutes;
      });
      
      // Check if total exceeds 24 hours (1440 minutes)
      if (totalMinutes > 1440) {
        isValid = false;
        // Highlight the issue
        totalTimeElement.classList.add('text-red-400');
      } else {
        totalTimeElement.classList.remove('text-red-400');
      }
      
      return isValid;
    };

    const propagateTimeChanges = (changedRow) => {
      let currentRow = changedRow;
      let nextRow = currentRow.nextElementSibling;
      
      while (nextRow) {
        if (!manualAdjustments.has(nextRow.dataset.rowId)) {
          const currentEndTime = currentRow.querySelector('.end-time').value;
          const nextStartSelect = nextRow.querySelector('.start-time');
          
          // Update next row's start time to match current row's end time
          nextStartSelect.value = currentEndTime;
          
          // Update duration for next row
          updateDuration(nextRow);
          
          // Move to next row
          currentRow = nextRow;
          nextRow = currentRow.nextElementSibling;
        } else {
          // If the next row is manually adjusted, stop propagation
          break;
        }
      }
      
      // Validate the total time doesn't exceed 24 hours
      validateTimeContinuity();
    };

    const updateSummary = () => {
      const rows = tableBody.querySelectorAll('tr');
      const categoryTimes = {};
      let totalMinutes = 0;
      
      // Initialize all categories with 0 minutes
      Object.keys(categories).forEach(cat => {
        categoryTimes[cat] = 0;
      });
      
      // Calculate time for each category
      rows.forEach(row => {
        const category = row.querySelector('.category-select').value;
        const durationCell = row.querySelector('.duration-cell');
        const minutes = parseInt(durationCell.dataset.totalMinutes) || 0;
        
        // Skip default category from summary
        if (category !== 'Default') {
          categoryTimes[category] += minutes;
          totalMinutes += minutes;
        }
      });
      
      // Cap total minutes at 24 hours (1440 minutes)
      const cappedMinutes = Math.min(totalMinutes, 1440);
      
      // Convert to hours and minutes for display
      const totalHours = Math.floor(cappedMinutes / 60);
      const totalMins = cappedMinutes % 60;
      totalTimeElement.textContent = `${totalHours}h ${totalMins}m`;
      
      // Generate summary HTML
      let summaryHTML = '';
      
      Object.entries(categoryTimes)
        .filter(([cat]) => cat !== 'Default') // Exclude Default from summary
        .sort((a, b) => b[1] - a[1])
        .forEach(([cat, minutes]) => {
          if (minutes > 0) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            const percentage = cappedMinutes > 0 ? (minutes / cappedMinutes * 100).toFixed(1) : 0;
            
            summaryHTML += `
              <div class="mb-3 sm:mb-4">
                <div class="flex justify-between mb-1">
                  <span class="font-medium text-sm sm:text-base">${cat}</span>
                  <span class="text-sm sm:text-base">${formatDuration(hours, mins)} (${percentage}%)</span>
                </div>
                <div class="w-full bg-gray-700 rounded-full h-4 sm:h-6 relative">
                  <div class="category-time-bar h-4 sm:h-6 rounded-full" style="width: ${percentage}%; background-color: ${categories[cat]}">
                    <span class="progress-label text-xs sm:text-sm">${percentage}%</span>
                  </div>
                </div>
              </div>
            `;
          }
        });
      
      categorySummary.innerHTML = summaryHTML || '<p class="text-gray-400 text-sm sm:text-base">No activities tracked yet.</p>';
      
      // Validate time continuity
      validateTimeContinuity();
    };

    const createDefaultRows = () => {
      tableBody.innerHTML = '';
      let currentTime = '00:00';
      
      for (let i = 0; i < 24; i++) {
        const endTime = minutesToTime(timeToMinutes(currentTime) + 60); // 1-hour intervals
        const row = createTaskRow(currentTime, endTime);
        tableBody.appendChild(row);
        updateRowColor(row, 'Default');
        currentTime = endTime;
      }
      
      // Add "+" buttons to all rows
      tableBody.querySelectorAll('tr').forEach(row => {
        addPlusButton(row);
      });
    };

    const getStorageKey = () => {
      if (!currentUser) return `taskSheetV2-${datePicker.value}`;
      return `taskSheetV2-${currentUser.id}-${datePicker.value}`;
    };

    const saveData = async () => {
      const data = [];
      const rows = tableBody.querySelectorAll('tr');
      
      rows.forEach(row => {
        const startTime = row.querySelector('.start-time').value;
        const endTime = row.querySelector('.end-time').value;
        const plan = row.querySelector('.planned-task').value;
        const actual = row.querySelector('.actual-activity').value;
        const category = row.querySelector('.category-select').value;
        const isManual = manualAdjustments.has(row.dataset.rowId);
        
        data.push({
          startTime,
          endTime,
          plan,
          actual,
          category,
          rowId: row.dataset.rowId,
          manual: isManual
        });
      });
      
      // Save to backend if user is authenticated
      if (authToken) {
        try {
          await fetch(`${API_BASE_URL}/tasks/${datePicker.value}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({ tasks: data })
          });
        } catch (error) {
          console.error('Error saving data to backend:', error);
        }
      }
      
      // Always save to localStorage as fallback
      const key = getStorageKey();
      localStorage.setItem(key, JSON.stringify(data));
      updateSummary();
    };

    const loadData = async () => {
      // First try to load from backend if user is authenticated
      if (authToken) {
        try {
          const response = await fetch(`${API_BASE_URL}/tasks/${datePicker.value}`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.tasks && data.tasks.length > 0) {
              // Clear default rows first
              tableBody.innerHTML = '';
              
              // Load saved tasks
              data.tasks.forEach((task) => {
                const row = createTaskRow(task.startTime, task.endTime, task);
                if (task.rowId) row.dataset.rowId = task.rowId;
                tableBody.appendChild(row);
                
                // Update duration display
                updateDuration(row);
                
                // Add to manual adjustments if needed
                if (task.manual) {
                  manualAdjustments.add(row.dataset.rowId);
                  row.querySelector('.start-time').classList.add('manual-adjust');
                }
                
                // Update row color
                updateRowColor(row, task.category || 'Default');
              });
              
              // Add "+" buttons to all rows
              tableBody.querySelectorAll('tr').forEach(row => {
                addPlusButton(row);
              });
              
              updateSummary();
              return;
            }
          }
        } catch (error) {
          console.error('Error loading data from backend:', error);
        }
      }
      
      // Fallback to localStorage if not authenticated or backend fails
      const key = getStorageKey();
      const savedData = JSON.parse(localStorage.getItem(key));
      
      // Clear manual adjustments
      manualAdjustments.clear();
      
      if (savedData && savedData.length > 0) {
        // Clear default rows first
        tableBody.innerHTML = '';
        
        // Load saved tasks
        savedData.forEach((task) => {
          const row = createTaskRow(task.startTime, task.endTime, task);
          if (task.rowId) row.dataset.rowId = task.rowId;
          tableBody.appendChild(row);
          
          // Update duration display
          updateDuration(row);
          
          // Add to manual adjustments if needed
          if (task.manual) {
            manualAdjustments.add(row.dataset.rowId);
            row.querySelector('.start-time').classList.add('manual-adjust');
          }
          
          // Update row color
          updateRowColor(row, task.category || 'Default');
        });
      } else {
        // Create default rows if no saved data
        createDefaultRows();
      }
      
      // Add "+" buttons to all rows
      tableBody.querySelectorAll('tr').forEach(row => {
        addPlusButton(row);
      });
      
      updateSummary();
    };

    const clearData = () => {
      if (confirm('Are you sure you want to clear all data for this day? This cannot be undone.')) {
        const rows = tableBody.querySelectorAll('tr');
        
        // Reset all rows to default values but keep the time structure
        let currentTime = '00:00';
        rows.forEach((row, index) => {
          // Reset start and end times to default hourly intervals
          const startSelect = row.querySelector('.start-time');
          const endSelect = row.querySelector('.end-time');
          
          startSelect.value = currentTime;
          const endTime = minutesToTime(timeToMinutes(currentTime) + 60);
          endSelect.value = endTime;
          
          // Update duration
          updateDuration(row);
          
          // Clear planned task
          const planInput = row.querySelector('.planned-task');
          planInput.value = '';
          
          // Clear actual activity
          const actualInput = row.querySelector('.actual-activity');
          actualInput.value = '';
          
          // Reset category to Default
          const categorySelect = row.querySelector('.category-select');
          categorySelect.value = 'Default';
          updateRowColor(row, 'Default');
          
          // Reset manual adjustments
          manualAdjustments.delete(row.dataset.rowId);
          startSelect.classList.remove('manual-adjust');
          
          // Set next start time to current end time
          currentTime = endTime;
        });
        
        saveData().catch(error => {
            console.error('Error saving data:', error);
          });
        }
    };

    const checkConnection = async () => {
      try {
        // In a real app, this would check connection to your backend
        // For demo purposes, we'll assume we're always online
        connectionStatus.textContent = 'Online';
        connectionStatus.classList.remove('offline');
        connectionStatus.classList.add('online');
        return true;
      } catch (error) {
        connectionStatus.textContent = 'Offline';
        connectionStatus.classList.remove('online');
        connectionStatus.classList.add('offline');
        return false;
      }
    };

    const addEventListeners = () => {
      datePicker.addEventListener('change', () => {
        loadData().catch(error => {
          console.error('Error loading data:', error);
        });
      });
      clearBtn.addEventListener('click', clearData);
      printBtn.addEventListener('click', () => window.print());
      saveBtn.addEventListener('click', () => {
        saveData().catch(error => {
          console.error('Error saving data:', error);
        });
      });
      loadBtn.addEventListener('click', () => {
        loadData().catch(error => {
          console.error('Error loading data:', error);
        });
      });

      // Event delegation for dynamic elements
      tableBody.addEventListener('input', (e) => {
        if (e.target.matches('.start-time')) {
          const row = e.target.closest('tr');
          
          // Mark as manually adjusted
          manualAdjustments.add(row.dataset.rowId);
          e.target.classList.add('manual-adjust');
          
          updateDuration(row);
          saveData().catch(error => {
            console.error('Error saving data:', error);
          });
        }
        
        if (e.target.matches('.end-time')) {
          const row = e.target.closest('tr');
          updateDuration(row);
          
          // Propagate time changes to all subsequent rows
          propagateTimeChanges(row);
          
          saveData().catch(error => {
            console.error('Error saving data:', error);
          });
        }
        
        if (e.target.matches('.planned-task, .actual-activity, .category-select')) {
          saveData().catch(error => {
            console.error('Error saving data:', error);
          });
          
          if (e.target.matches('.category-select')) {
            const row = e.target.closest('tr');
            updateRowColor(row, e.target.value);
          }
        }
      });

      tableBody.addEventListener('click', (e) => {
        if (e.target.matches('.delete-task')) {
          // Prevent deletion if we only have 24 rows (the minimum)
          if (tableBody.childElementCount <= 24) {
            alert("You need to have at least 24 time slots.");
            return;
          }
          
          const rowToDelete = e.target.closest('tr');
          const previousRow = rowToDelete.previousElementSibling;
          
          rowToDelete.remove();
          
          // If there's a previous row, adjust the next row's start time
          if (previousRow) {
            const nextRow = previousRow.nextElementSibling;
            if (nextRow && !manualAdjustments.has(nextRow.dataset.rowId)) {
              const previousEndTime = previousRow.querySelector('.end-time').value;
              const nextStartSelect = nextRow.querySelector('.start-time');
              nextStartSelect.value = previousEndTime;
              updateDuration(nextRow);
              
              // Propagate changes to all subsequent rows
              propagateTimeChanges(previousRow);
            }
          }
          
          saveData().catch(error => {
            console.error('Error saving data:', error);
          });
          
          // Add "+" button to the new last row
          const lastRow = tableBody.lastElementChild;
          if (lastRow && !lastRow.querySelector('.add-task-btn')) {
            addPlusButton(lastRow);
          }
        }
      });

      tableBody.addEventListener('change', (e) => {
        if (e.target.matches('.category-select')) {
          const row = e.target.closest('tr');
          updateRowColor(row, e.target.value);
          saveData().catch(error => {
            console.error('Error saving data:', error);
          });
        }
      });

      tableBody.addEventListener('change', (e) => {
        if (e.target.matches('.start-time')) {
          const row = e.target.closest('tr');
          const startSelect = e.target;
          const endSelect = row.querySelector('.end-time');
          const currentEndTime = endSelect.value;
          
          // Regenerate end time options
          const endTimeOptions = generateEndTimeOptions(startSelect.value);
          endSelect.innerHTML = '';
          endTimeOptions.forEach(time => {
            const option = document.createElement('option');
            option.value = time;
            option.textContent = time;
            // Keep the current end time if it's still valid
            if (time === currentEndTime && timeToMinutes(time) > timeToMinutes(startSelect.value)) {
              option.selected = true;
            }
            endSelect.appendChild(option);
          });
          
          // If current end time is invalid, select the next available time
          if (timeToMinutes(currentEndTime) <= timeToMinutes(startSelect.value)) {
            const nextTime = minutesToTime(timeToMinutes(startSelect.value) + 30);
            endSelect.value = nextTime;
          }
          
          updateDuration(row);
          propagateTimeChanges(row);
          saveData().catch(error => {
            console.error('Error saving data:', error);
          });
        }
      });
    };

    const initTaskPlanner = () => {
      // Get DOM elements
      datePicker = document.getElementById('date-picker');
      tableBody = document.getElementById('table-body');
      clearBtn = document.getElementById('clear-btn');
      printBtn = document.getElementById('print-btn');
      saveBtn = document.getElementById('save-btn');
      loadBtn = document.getElementById('load-btn');
      categorySummary = document.getElementById('category-summary');
      totalTimeElement = document.getElementById('total-time');
      connectionStatus = document.getElementById('connection-status');

      const today = new Date();
      datePicker.value = today.toISOString().split('T')[0];
      createDefaultRows();
      loadData();
      addEventListeners();
      checkConnection();
    };

    // Authentication Functions
    const checkAuthStatus = () => {
      const token = localStorage.getItem('authToken');
      const user = localStorage.getItem('currentUser');
      const tokenExpiry = localStorage.getItem('tokenExpiry');
      
      if (token && user && tokenExpiry) {
        // Check if token is still valid
        if (Date.now() < parseInt(tokenExpiry)) {
          authToken = token;
          currentUser = JSON.parse(user);
          showApp();
        } else {
          // Token expired, clear storage
          clearAuthData();
          showAuthModal();
        }
      } else {
        showAuthModal();
      }
    };

    const showAuthModal = () => {
      document.getElementById('auth-modal').style.display = 'flex';
      document.getElementById('app-container').classList.add('hidden');
    };

    const showApp = () => {
      document.getElementById('auth-modal').style.display = 'none';
      document.getElementById('app-container').classList.remove('hidden');
      document.getElementById('user-name').textContent = currentUser.name;
      
      // Initialize the task planner
      initTaskPlanner();
    };

    const clearAuthData = () => {
      localStorage.removeItem('authToken');
      localStorage.removeItem('currentUser');
      localStorage.removeItem('tokenExpiry');
      authToken = null;
      currentUser = null;
    };

    const handleLogin = async (email, password) => {
      try {
        const response = await fetch(`${API_BASE_URL}/login`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          // Set token expiry for 10 days
          const tokenExpiry = Date.now() + (10 * 24 * 60 * 60 * 1000);
          
          // Store auth data
          localStorage.setItem('authToken', data.token);
          localStorage.setItem('currentUser', JSON.stringify(data.user));
          localStorage.setItem('tokenExpiry', tokenExpiry.toString());
          
          authToken = data.token;
          currentUser = data.user;
          
          showApp();
          return { success: true };
        } else {
          return { success: false, message: data.message };
        }
      } catch (error) {
        return { success: false, message: 'Network error. Please try again.' };
      }
    };

    const handleRegister = async (name, email, password) => {
      try {
        const response = await fetch(`${API_BASE_URL}/register`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ name, email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          // Set token expiry for 10 days
          const tokenExpiry = Date.now() + (10 * 24 * 60 * 60 * 1000);
          
          // Store auth data
          localStorage.setItem('authToken', data.token);
          localStorage.setItem('currentUser', JSON.stringify(data.user));
          localStorage.setItem('tokenExpiry', tokenExpiry.toString());
          
          authToken = data.token;
          currentUser = data.user;
          
          showApp();
          return { success: true };
        } else {
          return { success: false, message: data.message };
        }
      } catch (error) {
        return { success: false, message: 'Network error. Please try again.' };
      }
    };

    const handleForgotPassword = async (email) => {
      try {
        const response = await fetch(`${API_BASE_URL}/forgot-password`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ email })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          return {
            success: true,
            message: data.message
          };
        } else {
          return { success: false, message: data.message };
        }
      } catch (error) {
        return { success: false, message: 'Network error. Please try again.' };
      }
    };

    const handleResetPassword = async (email, otp, newPassword) => {
      try {
        const response = await fetch(`${API_BASE_URL}/reset-password`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ email, otp, newPassword })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          return {
            success: true,
            message: data.message
          };
        } else {
          return { success: false, message: data.message };
        }
      } catch (error) {
        return { success: false, message: 'Network error. Please try again.' };
      }
    };

    const handleLogout = () => {
      clearAuthData();
      showAuthModal();
    };

    // Initialize the application
    document.addEventListener('DOMContentLoaded', () => {
      // Auth event listeners
      const authTabs = document.querySelectorAll('.auth-tab');
      const loginForm = document.getElementById('login-form');
      const registerForm = document.getElementById('register-form');
      const forgotForm = document.getElementById('forgot-form');
      const logoutBtn = document.getElementById('logout-btn');

      authTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabName = tab.getAttribute('data-tab');
          
          // Update active tab
          authTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Show corresponding form
          document.querySelectorAll('.auth-form').forEach(form => {
            form.classList.remove('active');
          });
          document.getElementById(`${tabName}-form`).classList.add('active');
        });
      });

      loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('login-email').value;
        const password = document.getElementById('login-password').value;
        const errorElement = document.getElementById('login-error');
        
        // Show loading state
        loginForm.classList.add('loading');
        
        const result = await handleLogin(email, password);
        
        // Remove loading state
        loginForm.classList.remove('loading');
        
        if (result.success) {
          errorElement.classList.add('hidden');
        } else {
          errorElement.textContent = result.message;
          errorElement.classList.remove('hidden');
        }
      });

      registerForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const name = document.getElementById('register-name').value;
        const email = document.getElementById('register-email').value;
        const password = document.getElementById('register-password').value;
        const confirm = document.getElementById('register-confirm').value;
        const errorElement = document.getElementById('register-error');
        
        // Basic validation
        if (password !== confirm) {
          errorElement.textContent = 'Passwords do not match';
          errorElement.classList.remove('hidden');
          return;
        }
        
        if (password.length < 6) {
          errorElement.textContent = 'Password must be at least 6 characters';
          errorElement.classList.remove('hidden');
          return;
        }
        
        // Show loading state
        registerForm.classList.add('loading');
        
        const result = await handleRegister(name, email, password);
        
        // Remove loading state
        registerForm.classList.remove('loading');
        
        if (result.success) {
          errorElement.classList.add('hidden');
        } else {
          errorElement.textContent = result.message;
          errorElement.classList.remove('hidden');
        }
      });

      forgotForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('forgot-email').value;
        const messageElement = document.getElementById('forgot-message');
        
        // Show loading state
        forgotForm.classList.add('loading');
        
        const result = await handleForgotPassword(email);
        
        // Remove loading state
        forgotForm.classList.remove('loading');
        
        if (result.success) {
          messageElement.textContent = result.message;
          messageElement.classList.remove('hidden');
          
          // Show OTP form after successful OTP send
          setTimeout(() => {
            // Set email in OTP form
            document.getElementById('otp-email').value = email;
            
            // Hide forgot form and show OTP form
            forgotForm.classList.remove('active');
            document.getElementById('otp-form').classList.add('active');
            
            // Update tabs
            authTabs.forEach(t => t.classList.remove('active'));
            document.querySelector('.auth-tab[data-tab="forgot"]').classList.add('active');
          }, 2000);
        } else {
          messageElement.textContent = result.message;
          messageElement.classList.remove('hidden');
        }
      });

      // Add event listener for OTP form
      const otpForm = document.getElementById('otp-form');
      otpForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('otp-email').value;
        const otp = document.getElementById('otp-code').value;
        const newPassword = document.getElementById('new-password').value;
        const confirmPassword = document.getElementById('confirm-password').value;
        const messageElement = document.getElementById('otp-message');
        const errorElement = document.getElementById('otp-error');
        
        // Basic validation
        if (newPassword !== confirmPassword) {
          errorElement.textContent = 'Passwords do not match';
          errorElement.classList.remove('hidden');
          return;
        }
        
        if (newPassword.length < 6) {
          errorElement.textContent = 'Password must be at least 6 characters';
          errorElement.classList.remove('hidden');
          return;
        }
        
        // Clear any previous error messages
        errorElement.classList.add('hidden');
        
        // Show loading state
        otpForm.classList.add('loading');
        
        const result = await handleResetPassword(email, otp, newPassword);
        
        // Remove loading state
        otpForm.classList.remove('loading');
        
        if (result.success) {
          messageElement.textContent = result.message;
          messageElement.classList.remove('hidden');
          
          // Clear form fields
          otpForm.reset();
          
          // Show login form after successful reset
          setTimeout(() => {
            // Hide OTP form and show login form
            otpForm.classList.remove('active');
            document.getElementById('login-form').classList.add('active');
            
            // Update tabs
            authTabs.forEach(t => t.classList.remove('active'));
            document.querySelector('.auth-tab[data-tab="login"]').classList.add('active');
          }, 2000);
        } else {
          errorElement.textContent = result.message;
          errorElement.classList.remove('hidden');
        }
      });

      logoutBtn.addEventListener('click', handleLogout);

      // Check authentication status on page load
      checkAuthStatus();
    });
  </script>
</body>
</html>